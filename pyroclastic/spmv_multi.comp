// Sparse Matrix vector multiplication (multi modular)
//
// The memory representation of M (or submatrices of M) will be:
// - a dense block of 30-50 columns with high density
// - a CSR for coefficients +1 (an index may appear multiple times for larger
// values)
// - a CSR for coefficients -1

#version 450

#ifndef N
#error Matrix dimension undefined
#endif

#ifndef DENSE_N
#error Dense width undefined
#endif

#ifndef MODULI
#error MODULI undefined
#endif

#ifndef BATCH_ROW
#error BATCH_ROW undefined
#endif

#ifdef INT64
#define WORD_T int64_t
#define UWORD_T uint64_t
#else
#define WORD_T int
#define UWORD_T uint
#endif

#define MODULI_PER_THREAD 4

#extension GL_EXT_control_flow_attributes : require
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int16 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_shader_atomic_int64 : require

// Each thread handles a modulus (x) and row (y)
layout(local_size_x = MODULI / MODULI_PER_THREAD, local_size_y = BATCH_ROW,
       local_size_z = 1) in;

layout(binding = 0) readonly buffer Dense { int8_t dense[]; };
layout(binding = 1) readonly buffer SparsePlus { uint16_t plus[]; };
layout(binding = 2) readonly buffer SparseMinus { uint16_t minus[]; };
layout(binding = 3) readonly buffer IdxPlus { uint idxPlus[]; };
layout(binding = 4) readonly buffer IdxMinus { uint idxMinus[]; };
// Vector of size 2N Moduli:
// even iterations do V[N:2N] = M * V[0:N]
// odd iterations do V[0:N] = M * V[N:2N]
layout(binding = 5) buffer V { UWORD_T v[]; };
// Vector of identical values (1 per workgroup) indicating iteration count
layout(binding = 6) buffer Iter { uint iter[]; };
// Output mask for Wiedemann algorithm sequence.
layout(binding = 7) coherent buffer Wsel { uint8_t wsel[]; };
// Output buffer for Wiedemann algorithm sequence: wout[iter] = sum(v[idx] where
// wsel[idx]=1)
layout(binding = 8) coherent buffer Wout { uint64_t wout[]; };
layout(binding = 9) readonly buffer Moduli { UWORD_T moduli[]; };

UWORD_T fastmod(WORD_T x, UWORD_T p) {
  float pinv = 1.0 / float(p);
  x -= WORD_T(p) * WORD_T(int(floor(float(x) * pinv)));
  if (x < 0)
    x += WORD_T(p);
  return UWORD_T(x);
}

void main() {
  uint idx = iter[gl_WorkGroupID.y];
  uint midx = gl_LocalInvocationID.x;
  uint off0 = ((idx & 1) == 0) ? 0 : N * MODULI;
  uint off1 = ((idx & 1) == 0) ? N * MODULI : 0;
  uint row = gl_GlobalInvocationID.y;
  if (row >= N)
    return;
  WORD_T acc[MODULI_PER_THREAD];
  for (uint j = 0; j < MODULI_PER_THREAD; j++)
    acc[j] = 0;
  // Dense block
  uint dense_base = row * DENSE_N;
  for (uint i = 0; i < DENSE_N; i++) {
    for (uint j = 0; j < MODULI_PER_THREAD; j++)
      acc[j] +=
          WORD_T(dense[dense_base + i]) *
          WORD_T(
              v[off0 + MODULI * i + midx + j * (MODULI / MODULI_PER_THREAD)]);
  }
  // +1 coefficients
  uint plus0 = idxPlus[row];
  uint plus1 = idxPlus[row + 1];
  uint base = 0;
  for (uint i = plus0; i < plus1; i++) {
    uint c = plus[i];
    if (N >= 0xffff && c == 0xffff) {
      base += 0xffff;
      continue;
    }
    for (uint j = 0; j < MODULI_PER_THREAD; j++)
      acc[j] += WORD_T(v[off0 + MODULI * (base + c) + midx +
                         j * (MODULI / MODULI_PER_THREAD)]);
  }
  // -1 coefficients
  uint minus0 = idxMinus[row];
  uint minus1 = idxMinus[row + 1];
  base = 0;
  for (uint i = minus0; i < minus1; i++) {
    uint c = minus[i];
    if (N >= 0xffff && c == 0xffff) {
      base += 0xffff;
      continue;
    }
    for (uint j = 0; j < MODULI_PER_THREAD; j++)
      acc[j] -= WORD_T(v[off0 + MODULI * (base + c) + midx +
                         j * (MODULI / MODULI_PER_THREAD)]);
  }
  // Output result to next row
  for (uint j = 0; j < MODULI_PER_THREAD; j++) {
    const UWORD_T uacc =
        fastmod(acc[j], moduli[midx + j * (MODULI / MODULI_PER_THREAD)]);
    v[off1 + MODULI * row + midx + j * (MODULI / MODULI_PER_THREAD)] = uacc;
    if (gl_LocalInvocationID.y == wsel[gl_WorkGroupID.y]) {
      atomicAdd(wout[MODULI * idx + midx + j * (MODULI / MODULI_PER_THREAD)],
                uacc);
    }
  }
  barrier();
  if (gl_LocalInvocationID == uvec3(0))
    iter[gl_WorkGroupID.y] = idx + 1;
}
